# Configuration for Datasource
spring:
  datasource:
    url: ${JDBC_DATABASE_URL}
    username: ${JDBC_DATABASE_USERNAME}
    password: ${JDBC_DATABASE_PASSWORD}
    driver-class-name: "org.postgresql.Driver"
# for Hikari
    hikari:
      auto-commit: true
      minimum-idle: 5
      maximum-pool-size: 20

  mail:
    host: ${LOG_MAIL_HOST}
    port: ${LOG_MAIL_PORT}
    username: ${LOG_MAIL_USER}
    password: ${LOG_MAIL_PASS}
    properties:
      mail.smtp.auth: true
      mail.smtp.starttls.enable: true

  jpa:
    database: postgresql
  cache:
    type: caffeine
    cache-names: cacheGenres
    caffeine:
      spec: expireAfterWrite=30s

# Default mapping for servlet
server:
  servlet:
    context-path: "/v1/"

# Count for random movies
# Doesn't work as "random.count: 3" !!!
randoms:
  count: 3

#Common scheduler
scheduler:
  pool-size: 5

#Scheduled tasks
scheduled:
  # 08 and 16 o'clock of every weekday
  currency:
    cron: "0 0 8,18 * * MON-FRI"
  reports:
    cleanDone: "15 15 15 * 7 MON"
    checkQueueTimeout: 600000

# Currency
currency:
  datePattern: "yyyyMMdd"
  url: "https://bank.gov.ua/NBUStatService/v1/statdirectory/exchange"

# Authentification
auth:
  session:
    # Session timeout 2 hours = 2 * 60 * 60 = 7200 sec.
    timeout: 7200
    # Check session timeout 10 min = 10 * 60 * 1000 = 600000 millisec.
    checkTimeout: 600000

# Spring logging level
logging:
  level:
    root: debug
    org:
      springframwork: info

#management.security.enabled: false
# for Actuator http://localhost:8080/v1/actuator
management:
  endpoints:
    web:
      exposure:
        include: "*"

# threadPool
threadPool:
  corePoolSize: 5
  maxPoolSize: 50
  keepAliveSec: 60

# Parallel enrichment
parallelEnrichment:
  timeout: 4000

# Sql queries
queries:
  movies:
    allMoviesSql: "SELECT * FROM movie /*ORDER BY*/;"
    randomMoviesSql: "SELECT * FROM movie ORDER BY random() limit ?;"
    moviesByGenreIdSql: "SELECT m.* FROM movie m INNER JOIN movie_genre mg ON m.id = mg.movie_id WHERE mg.genre_id = ? /*ORDER BY*/ "
    movieByIdSql: "SELECT * FROM movie WHERE id = ?;"
    addMovieSql: "INSERT INTO movie (name_russian,name_native,year_of_release,description,rating,price,picture_path) VALUES (:nameRussian,:nameNative,:yearOfRelease,:description,:rating,:price,:picturePath);"
    editMovieSql: "INSERT INTO movie (id,name_russian,name_native,year_of_release,description,rating,price,picture_path) VALUES (:id,:nameRussian,:nameNative,:yearOfRelease,:description,:rating,:price,:picturePath) ON CONFLICT ON CONSTRAINT movie_pkey DO UPDATE    SET name_russian = EXCLUDED.name_russian,name_native = EXCLUDED.name_native,year_of_release = EXCLUDED.year_of_release,description = EXCLUDED.description,rating = EXCLUDED.rating,price = EXCLUDED.price,picture_path = EXCLUDED.picture_path;"
  genres:
    allGenresSql: "SELECT * FROM genre;"
    genresByMovieIdSql: "SELECT g.* FROM movie_genre mg INNER JOIN genre g ON mg.genre_id = g.id WHERE movie_id = ?;"
    deleteGenresByMovieIdSql: "DELETE FROM movie_genre WHERE movie_id = ?;"
    insertGenresByMovieIdSql: "INSERT INTO movie_genre (movie_id, genre_id) values (?, ?);"
  reviews:
    reviewsByMovieIdSql: "SELECT r.* FROM review r INNER JOIN users u ON r.user_id = u.id WHERE r.movie_id = ?;"
    addReviewSql: "INSERT INTO review (movie_id, user_id, text) VALUES (?, ?, ?);"
  users:
    usersByIdsSql: "SELECT u.* FROM users u WHERE u.id in (:ids);"
    userByAuthSql: "SELECT u.* FROM users u WHERE (u.email = ?) AND (u.pswhash = crypt(?, pswhash));"
  countries:
    allCountriesSql: "SELECT * FROM country;"
    countriesByMovieIdSql: "SELECT c.* FROM movie_country mc INNER JOIN country c ON mc.country_id = c.id WHERE movie_id = ?;"
    deleteCountriesByMovieIdSql: "DELETE FROM movie_country WHERE movie_id = ?;"
    insertCountriesByMovieIdSql: "INSERT INTO movie_country (movie_id, country_id) values (?, ?);"
  reports:
    activeReportsSql: "SELECT * FROM report WHERE deleted = 0;"
    addReportSql: "INSERT INTO report (deleted,status,file,link,type,output_type,user_id,date_from,date_to) VALUES (:deleted,:status,:file,:link,:type,:output_type,:user_id,:date_from,:date_to);"
    editReportSql: "INSERT INTO report (id,deleted,status,file,link,type,output_type,user_id,date_from,date_to) VALUES (:id,:deleted,:status,:file,:link,:type,:output_type,:user_id,:date_from,:date_to) ON CONFLICT ON CONSTRAINT report_pkey DO UPDATE SET deleted = EXCLUDED.deleted,status = EXCLUDED.status,link = EXCLUDED.link,type = EXCLUDED.type,output_type = EXCLUDED.output_type, user_id = EXCLUDED.user_id, date_from = EXCLUDED.date_to;"
    allReportMovieDetailSql: "select m.id movie_id, m.name_russian title, m.description, gn.genre_names genre, m.price, m.created_date add_date, m.modified_date, m.rating, count(r.id)  reviews_count from movie m LEFT JOIN ( SELECT mg.movie_id, string_agg(g.name, ',' ORDER BY g.id) AS genre_names FROM movie_genre mg JOIN genre g ON mg.genre_id = g.id GROUP BY mg.movie_id) gn ON m.id = gn.movie_id left join review r on m.id = r.movie_id group by m.id, m.name_russian, m.description, gn.genre_names, m.price, m.created_date, m.modified_date, m.rating"
    periodReportMovieDetailSql: "select m.id movie_id, m.name_russian title, m.description, gn.genre_names genre, m.price, m.created_date add_date, m.modified_date, m.rating, count(r.id)  reviews_count from movie m LEFT JOIN ( SELECT mg.movie_id, string_agg(g.name, ',' ORDER BY g.id) AS genre_names FROM movie_genre mg JOIN genre g ON mg.genre_id = g.id GROUP BY mg.movie_id) gn ON m.id = gn.movie_id left join review r on m.id = r.movie_id where m.created_date >= :date_from and m.created_date <= :date_to group by m.id, m.name_russian, m.description, gn.genre_names, m.price, m.created_date, m.modified_date, m.rating"
    top5UserDetailSql: "select r.user_id, u.email, count(r.id) as reviews_count, avg(m.rating) as average_rate from review r inner join users u on r.user_id = u.id	inner join movie m on r.movie_id = m.id group by r.user_id, u.email order by 3 desc, 4 desc limit 5"
    cleanReportSql: "select * from report r where r.status = 'DONE'"

reports:
  dir: ${TEMP}
  ftp:
    url: ${FTP_URL}
    port: ${FTP_PORT}
    username: ${FTP_USERNAME}
    password: ${FTP_PASSWORD}
  mailList: ${REPORT_MAIL_LIST}

debug:
  cache:
    # for cache testing (max heap size -Xmx28m)
    movieWeight: 2000000
  slowService:
    pause: 3800
